From Coq Require Import ZArith Reals Psatz.
From Coq Require Import Arith.Arith.
From Coq Require Import Logic.FunctionalExtensionality. 
From Coquelicot Require Import Coquelicot.

Open Scope R_scope.

Section EulerDefs.

Variable h : R.
Variable y : R.
Variable F : R -> R.

Fixpoint mod_eq (f: nat -> R -> R -> R) (method: R) (n: nat) (x : R) : R :=
  match n with
  | 0 => 0 
  | 1 => 0
  | S n  => h^(pred n) * (f n method x) + mod_eq f method n x
  end.

Fixpoint diff_y (n: nat) (t: R -> R) (x : R) : R :=
  let t' := t x  in 
  match n with  
  | 0 => x
  | S n => (Derive (diff_y n t) x) * t'
  end.

Fixpoint fcoe_fix (n:nat) (method: R) (x: R) : R := 
  let t  := mod_eq fcoe_fix method n in 
  match n with
  | 0 => 0
  | 1 => F x
  | (S n as m) => 
    let ytilde := sum_f_R0 (fun k => (h^k * (diff_y k t x) / INR (fact k))) in 
    method - (ytilde m) 
  end.

Definition fcoe (n : nat) (method: R) (x : R) : R := (fcoe_fix n method x) .

Definition ModEq (n: nat) (method: R) (x : R) : R := sum_f_R0 (fun j => (h^(j-1) * (fcoe j method x))) n.

Definition Euler: R :=  y + h * F y.

End EulerDefs. 

Definition F y:=  y^2.

Check F.

Check fcoe. 

Check Euler.

Lemma fcoe1 (h y : R) :
  fcoe h F 1 (Euler h y F) y = h * F y.
Proof.
intros. unfold fcoe, Euler, fcoe_fix, F; simpl. field_simplify. auto with real.
Qed. 


Lemma fcoe2 (h y : R) :
  fcoe h F 2 (Euler h y F) y = -h^2 * y^3.
Proof.
unfold fcoe, Euler, fcoe_fix, F; simpl. field_simplify. 
-replace (Derive (fun x : R => x) y) 
  with 1 
  by (symmetry; apply is_derive_unique; auto_derive; auto).
-replace (fun x : R => Derive (fun x0 : R => x0) x * (1 * (x * (x * 1)))) 
  with (fun x : R => Derive (fun x0 : R => x0) x * x^2)
  by (apply functional_extensionality; intros;
     replace ((1 * (x * (x * 1)))) with (x^2) by (nra);
     auto).
-replace (Derive (fun x : R => Derive (fun x0 : R => x0) x * x^2) y) 
  with (Derive (fun x : R => x^2) y).
-replace (Derive (fun x : R => x^2) y) 
  with (2*y) 
  by (symmetry; apply is_derive_unique; auto_derive; nra);
  field_simplify; auto; nra. 
apply Derive_ext; symmetry.
replace (Derive (fun x0 : R => x0) t) with 1. nra. 
symmetry; apply is_derive_unique; auto_derive; auto.
Qed. 


Lemma fcoe3 (h y : R) :
  fcoe h F 3 (Euler h y F) y = h^2 *(3/2)* y^4.
Proof.
unfold fcoe, Euler, fcoe_fix, F; simpl. field_simplify. 
-replace
((fun x : R =>
    Derive
      (fun x0 : R =>
       Derive (fun x1 : R => x1) x0 *
       (h * 1 *
        (y + h * (y * (y * 1)) -
         (1 * x0 / 1 + h * 1 * (Derive (fun x1 : R => x1) x0 * 0) / 1)))) x *
    (h * 1 *
     (y + h * (y * (y * 1)) -
      (1 * x / 1 + h * 1 * (Derive (fun x0 : R => x0) x * 0) / 1)))))
with (fun x : R => -h * (h * (y + h * (y^2) - x ))).
-replace (Derive (fun x : R => - h * (h * (y + h * y ^ 2 - x))) y)
with (h^2 * )


-replace (Derive (fun x : R => x) y) 
  with 1 
  by (symmetry; apply is_derive_unique; auto_derive; auto).
-replace (Derive
   (fun x : R =>
    Derive (fun x0 : R => x0) x *
    (h * 1 *
     (y + h * (y * (y * 1)) -
      (1 * x / 1 + h * 1 * (Derive (fun x0 : R => x0) x * 0) / 1)))) y)
  with
(Derive
   (fun x : R =>  x * (h * (y + h * y^2 - x))) y) .
field_simplify.
replace  (Derive
   (fun x : R =>(- h^2 *x^2 ))
   y) with (-2*h^2*y).
-replace (fun x : R =>
    Derive
      (fun x0 : R =>
       Derive (fun x1 : R => x1) x0 *
       (h * 1 *
        (1 * x0 / 1 + h * 1 * (Derive (fun x1 : R => x1) x0 * 0) / 1 - x0 -
         h * (x0 * (x0 * 1))))) x *
    (h * 1 *
     (1 * x / 1 + h * 1 * (Derive (fun x0 : R => x0) x * 0) / 1 - x - h * (x * (x * 1)))))
with (fun x : R => 2*h^4*x^3).
-replace (Derive (fun x : R => 2 * h ^ 4 * x ^ 3) y) with (6*h^4*y^2).
field_simplify. 
-replace (Derive (fun x : R => h * - x ^ 2) y)
  with (-2*h* y)
  by (symmetry; apply is_derive_unique; auto_derive; nra).
-replace (Derive
   (fun x : R =>
    Derive (fun x0 : R => h * - x0 ^ 2) x *
    (h * 1 * (1 * x / 1 + 1 * (Derive (fun x0 : R => x0) x * 0) / 1 - x - x * (x * 1)))) y)
  with
  (6 * h^2 * y^2).
field_simplify. 
replace (Derive
   (fun x : R =>
    2 * h^2 * x^3) y) with (6 * h^2 * y^2).
field_simplify. 
  
apply Derive_ext; symmetry. 
replace (Derive (fun x0 : R => x0) t) with 1. nra. 
symmetry; apply is_derive_unique; auto_derive; auto.
Qed. 



